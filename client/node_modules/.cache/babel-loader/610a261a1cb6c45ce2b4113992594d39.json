{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\gksdb\\\\Desktop\\\\2019-2-OSSP1-Buzz-5\\\\client\\\\src\\\\containers\\\\MediaContainer.js\";\nimport React, { Component } from 'react';\nimport { PropTypes } from 'prop-types';\n\nclass MediaBridge extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      bridge: '',\n      user: ''\n    };\n    this.onRemoteHangup = this.onRemoteHangup.bind(this);\n    this.onMessage = this.onMessage.bind(this);\n    this.sendData = this.sendData.bind(this);\n    this.setupDataHandlers = this.setupDataHandlers.bind(this);\n    this.setDescription = this.setDescription.bind(this);\n    this.sendDescription = this.sendDescription.bind(this);\n    this.hangup = this.hangup.bind(this);\n    this.init = this.init.bind(this);\n    this.setDescription = this.setDescription.bind(this);\n  }\n\n  componentWillMount() {\n    // chrome polyfill for connection between the local device and a remote peer\n    window.RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection;\n    this.props.media(this);\n  }\n\n  componentDidMount() {\n    this.props.getUserMedia.then(stream => this.localVideo.srcObject = this.localStream = stream);\n    this.props.socket.on('message', this.onMessage);\n    this.props.socket.on('hangup', this.onRemoteHangup);\n  }\n\n  componentWillUnmount() {\n    this.props.media(null);\n\n    if (this.localStream !== undefined) {\n      this.localStream.getVideoTracks()[0].stop();\n    }\n\n    this.props.socket.emit('leave');\n  }\n\n  onRemoteHangup() {\n    this.setState({\n      user: 'host',\n      bridge: 'host-hangup'\n    });\n  }\n\n  onMessage(message) {\n    if (message.type === 'offer') {\n      // set remote description and answer\n      this.pc.setRemoteDescription(new RTCSessionDescription(message));\n      this.pc.createAnswer().then(this.setDescription).then(this.sendDescription).catch(this.handleError); // An error occurred, so handle the failure to connect\n    } else if (message.type === 'answer') {\n      // set remote description\n      this.pc.setRemoteDescription(new RTCSessionDescription(message));\n    } else if (message.type === 'candidate') {\n      // add ice candidate\n      this.pc.addIceCandidate(new RTCIceCandidate({\n        sdpMLineIndex: message.mlineindex,\n        candidate: message.candidate\n      }));\n    }\n  }\n\n  sendData(msg) {\n    this.dc.send(JSON.stringify(msg));\n  } // Set up the data channel message handler\n\n\n  setupDataHandlers() {\n    this.dc.onmessage = e => {\n      var msg = JSON.parse(e.data);\n      console.log('received message over data channel:' + msg);\n    };\n\n    this.dc.onclose = () => {\n      this.remoteStream.getVideoTracks()[0].stop();\n      console.log('The Data Channel is Closed');\n    };\n  }\n\n  setDescription(offer) {\n    this.pc.setLocalDescription(offer);\n  } // send the offer to a server to be forwarded to the other peer\n\n\n  sendDescription() {\n    this.props.socket.send(this.pc.localDescription);\n  }\n\n  hangup() {\n    this.setState({\n      user: 'guest',\n      bridge: 'guest-hangup'\n    });\n    this.pc.close();\n    this.props.socket.emit('leave');\n  }\n\n  handleError(e) {\n    console.log(e);\n  }\n\n  init() {\n    // wait for local media to be ready\n    const attachMediaIfReady = () => {\n      this.dc = this.pc.createDataChannel('chat');\n      this.setupDataHandlers();\n      console.log('attachMediaIfReady');\n      this.pc.createOffer().then(this.setDescription).then(this.sendDescription).catch(this.handleError); // An error occurred, so handle the failure to connect\n    }; // set up the peer connection\n    // this is one of Google's public STUN servers\n    // make sure your offer/answer role does not change. If user A does a SLD\n    // with type=offer initially, it must do that during  the whole session\n\n\n    this.pc = new RTCPeerConnection({\n      iceServers: [{\n        url: 'stun:stun.l.google.com:19302'\n      }]\n    }); // when our browser gets a candidate, send it to the peer\n\n    this.pc.onicecandidate = e => {\n      console.log(e, 'onicecandidate');\n\n      if (e.candidate) {\n        this.props.socket.send({\n          type: 'candidate',\n          mlineindex: e.candidate.sdpMLineIndex,\n          candidate: e.candidate.candidate\n        });\n      }\n    }; // when the other side added a media stream, show it on screen\n\n\n    this.pc.onaddstream = e => {\n      console.log('onaddstream', e);\n      this.remoteStream = e.stream;\n      this.remoteVideo.srcObject = this.remoteStream = e.stream;\n      this.setState({\n        bridge: 'established'\n      });\n    };\n\n    this.pc.ondatachannel = e => {\n      // data channel\n      this.dc = e.channel;\n      this.setupDataHandlers();\n      this.sendData({\n        peerMediaStream: {\n          video: this.localStream.getVideoTracks()[0].enabled\n        }\n      }); //sendData('hello');\n    }; // attach local media to the peer connection\n\n\n    this.localStream.getTracks().forEach(track => this.pc.addTrack(track, this.localStream)); // call if we were the last to connect (to increase\n    // chances that everything is set up properly at both ends)\n\n    if (this.state.user === 'host') {\n      this.props.getUserMedia.then(attachMediaIfReady);\n    }\n  }\n\n  render() {\n    return React.createElement(\"div\", {\n      className: \"media-bridge \".concat(this.state.bridge),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 148\n      },\n      __self: this\n    }, React.createElement(\"video\", {\n      className: \"remote-video\",\n      ref: ref => this.remoteVideo = ref,\n      autoPlay: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 149\n      },\n      __self: this\n    }), React.createElement(\"video\", {\n      className: \"local-video\",\n      ref: ref => this.localVideo = ref,\n      autoPlay: true,\n      muted: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 150\n      },\n      __self: this\n    }));\n  }\n\n}\n\nMediaBridge.propTypes = {\n  socket: PropTypes.object.isRequired,\n  getUserMedia: PropTypes.object.isRequired,\n  media: PropTypes.func.isRequired\n};\nexport default MediaBridge;","map":{"version":3,"sources":["C:\\Users\\gksdb\\Desktop\\2019-2-OSSP1-Buzz-5\\client\\src\\containers\\MediaContainer.js"],"names":["React","Component","PropTypes","MediaBridge","constructor","props","state","bridge","user","onRemoteHangup","bind","onMessage","sendData","setupDataHandlers","setDescription","sendDescription","hangup","init","componentWillMount","window","RTCPeerConnection","webkitRTCPeerConnection","media","componentDidMount","getUserMedia","then","stream","localVideo","srcObject","localStream","socket","on","componentWillUnmount","undefined","getVideoTracks","stop","emit","setState","message","type","pc","setRemoteDescription","RTCSessionDescription","createAnswer","catch","handleError","addIceCandidate","RTCIceCandidate","sdpMLineIndex","mlineindex","candidate","msg","dc","send","JSON","stringify","onmessage","e","parse","data","console","log","onclose","remoteStream","offer","setLocalDescription","localDescription","close","attachMediaIfReady","createDataChannel","createOffer","iceServers","url","onicecandidate","onaddstream","remoteVideo","ondatachannel","channel","peerMediaStream","video","enabled","getTracks","forEach","track","addTrack","render","ref","propTypes","object","isRequired","func"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\r\nimport { PropTypes } from 'prop-types';\r\n\r\nclass MediaBridge extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      bridge: '',\r\n      user: ''\r\n    }\r\n    this.onRemoteHangup = this.onRemoteHangup.bind(this);\r\n    this.onMessage = this.onMessage.bind(this);\r\n    this.sendData = this.sendData.bind(this);\r\n    this.setupDataHandlers = this.setupDataHandlers.bind(this);\r\n    this.setDescription = this.setDescription.bind(this);\r\n    this.sendDescription = this.sendDescription.bind(this);\r\n    this.hangup = this.hangup.bind(this);\r\n    this.init = this.init.bind(this);\r\n    this.setDescription = this.setDescription.bind(this);\r\n  }\r\n  componentWillMount() {\r\n    // chrome polyfill for connection between the local device and a remote peer\r\n    window.RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection;\r\n    this.props.media(this);\r\n  }\r\n  componentDidMount() {\r\n    this.props.getUserMedia\r\n      .then(stream => this.localVideo.srcObject = this.localStream = stream);\r\n    this.props.socket.on('message', this.onMessage);\r\n    this.props.socket.on('hangup', this.onRemoteHangup);\r\n  }\r\n  componentWillUnmount() {\r\n    this.props.media(null);\r\n    if (this.localStream !== undefined) {\r\n      this.localStream.getVideoTracks()[0].stop();\r\n    }\r\n    this.props.socket.emit('leave');\r\n  }\r\n  onRemoteHangup() {\r\n    this.setState({user: 'host', bridge: 'host-hangup'});\r\n  }\r\n  onMessage(message) {\r\n      if (message.type === 'offer') {\r\n          // set remote description and answer\r\n          this.pc.setRemoteDescription(new RTCSessionDescription(message));\r\n          this.pc.createAnswer()\r\n            .then(this.setDescription)\r\n            .then(this.sendDescription)\r\n            .catch(this.handleError); // An error occurred, so handle the failure to connect\r\n\r\n      } else if (message.type === 'answer') {\r\n          // set remote description\r\n          this.pc.setRemoteDescription(new RTCSessionDescription(message));\r\n      } else if (message.type === 'candidate') {\r\n          // add ice candidate\r\n          this.pc.addIceCandidate(\r\n              new RTCIceCandidate({\r\n                  sdpMLineIndex: message.mlineindex,\r\n                  candidate: message.candidate\r\n              })\r\n          );\r\n      }\r\n  }\r\n  sendData(msg) {\r\n    this.dc.send(JSON.stringify(msg))\r\n  }\r\n  // Set up the data channel message handler\r\n  setupDataHandlers() {\r\n      this.dc.onmessage = e => {\r\n          var msg = JSON.parse(e.data);\r\n          console.log('received message over data channel:' + msg);\r\n      };\r\n      this.dc.onclose = () => {\r\n        this.remoteStream.getVideoTracks()[0].stop();\r\n        console.log('The Data Channel is Closed');\r\n      };\r\n  }\r\n  setDescription(offer) {\r\n    this.pc.setLocalDescription(offer);\r\n  }\r\n  // send the offer to a server to be forwarded to the other peer\r\n  sendDescription() {\r\n    this.props.socket.send(this.pc.localDescription);\r\n  }\r\n  hangup() {\r\n    this.setState({user: 'guest', bridge: 'guest-hangup'});\r\n    this.pc.close();\r\n    this.props.socket.emit('leave');\r\n  }\r\n  handleError(e) {\r\n    console.log(e);\r\n  }\r\n  init() {\r\n    // wait for local media to be ready\r\n    const attachMediaIfReady = () => {\r\n      this.dc = this.pc.createDataChannel('chat');\r\n      this.setupDataHandlers();\r\n      console.log('attachMediaIfReady')\r\n      this.pc.createOffer()\r\n        .then(this.setDescription)\r\n        .then(this.sendDescription)\r\n        .catch(this.handleError); // An error occurred, so handle the failure to connect\r\n    }\r\n    // set up the peer connection\r\n    // this is one of Google's public STUN servers\r\n    // make sure your offer/answer role does not change. If user A does a SLD\r\n    // with type=offer initially, it must do that during  the whole session\r\n    this.pc = new RTCPeerConnection({iceServers: [{url: 'stun:stun.l.google.com:19302'}]});\r\n    // when our browser gets a candidate, send it to the peer\r\n    this.pc.onicecandidate = e => {\r\n        console.log(e, 'onicecandidate');\r\n        if (e.candidate) {\r\n            this.props.socket.send({\r\n                type: 'candidate',\r\n                mlineindex: e.candidate.sdpMLineIndex,\r\n                candidate: e.candidate.candidate\r\n            });\r\n        }\r\n    };\r\n    // when the other side added a media stream, show it on screen\r\n    this.pc.onaddstream = e => {\r\n        console.log('onaddstream', e) \r\n        this.remoteStream = e.stream;\r\n        this.remoteVideo.srcObject = this.remoteStream = e.stream;\r\n        this.setState({bridge: 'established'});\r\n    };\r\n    this.pc.ondatachannel = e => {\r\n        // data channel\r\n        this.dc = e.channel;\r\n        this.setupDataHandlers();\r\n        this.sendData({\r\n          peerMediaStream: {\r\n            video: this.localStream.getVideoTracks()[0].enabled\r\n          }\r\n        });\r\n        //sendData('hello');\r\n    };\r\n    // attach local media to the peer connection\r\n    this.localStream.getTracks().forEach(track => this.pc.addTrack(track, this.localStream));\r\n    // call if we were the last to connect (to increase\r\n    // chances that everything is set up properly at both ends)\r\n    if (this.state.user === 'host') {\r\n      this.props.getUserMedia.then(attachMediaIfReady);\r\n    }  \r\n  }\r\n  render(){\r\n    return (\r\n      <div className={`media-bridge ${this.state.bridge}`}>\r\n        <video className=\"remote-video\" ref={(ref) => this.remoteVideo = ref} autoPlay></video>\r\n        <video className=\"local-video\" ref={(ref) => this.localVideo = ref} autoPlay muted></video>\r\n      </div>\r\n    );\r\n  }\r\n}\r\nMediaBridge.propTypes = {\r\n  socket: PropTypes.object.isRequired,\r\n  getUserMedia: PropTypes.object.isRequired,\r\n  media: PropTypes.func.isRequired\r\n}\r\nexport default MediaBridge;"]},"metadata":{},"sourceType":"module"}