{"ast":null,"code":"// const pool = require('../config/dbPool.js');\n// module.exports = {\t\t\t\t\t\t\t// 두 개의 메소드 module화\n// \tqueryParam_None : async (...args) => {\t\t\t\t\t\t\t\t// (...args) expression은 arrow function 사\n// \t\tconst query = args[0];\n// \t\tlet result;\n// \t\ttry {\n// \t\t\tvar connection = await pool.getConnection();\t\t\t// connection을 pool에서 하나 가져온다.\n// \t\t\tresult = await connection.query(query) || null;\t\t// query문의 결과 || null 값이 result에 들어간다.\n// \t\t} catch(err) {\n// \t\t\tnext(err);\n// \t\t} finally {\n// \t\t\t//pool.releaseConnection(connection);\t\t\t\t\t\t\t\t// waterfall 에서는 connection.release()를 사용했지만, 이 경우 pool.releaseConnection(connection) 을 해준다.\n// console.log(connection);\n// \t\t\treturn result;\n// \t\t}\n// \t},\n// \tqueryParam_Arr : async (...args) => {\n// \t\tconst query = args[0];\n// \t\tconst value = args[1];\t// array\n// \t\tlet result;\n// \t\ttry {\n// \t\t\tvar connection = await pool.getConnection();\t\t\t// connection을 pool에서 하나 가져온다.\n// \t\t\tresult = await connection.query(query, value) || null;\t// 두 번째 parameter에 배열 => query문에 들어갈 runtime 시 결정될 value\n// \t\t} catch(err) {\n// \t\t\tnext(err);\n// \t\t\t//print(\"aaaaaaaaa\");\n// \t\t} finally {\n// \t\t\tpool.releaseConnection(connection);\t\t\t\t\t\t\t\t// waterfall 에서는 connection.release()를 사용했지만, 이 경우 pool.releaseConnection(connection) 을 해준다.\n// \t\t\treturn result;\n// \t\t}\n// \t}\n// };","map":{"version":3,"sources":["/Users/seojin-won/wisdom-x-wisdom/client/src/Server/module/pool.js"],"names":[],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// const pool = require('../config/dbPool.js');\n\n// module.exports = {\t\t\t\t\t\t\t// 두 개의 메소드 module화\n// \tqueryParam_None : async (...args) => {\t\t\t\t\t\t\t\t// (...args) expression은 arrow function 사\n// \t\tconst query = args[0];\n// \t\tlet result;\n\n// \t\ttry {\n// \t\t\tvar connection = await pool.getConnection();\t\t\t// connection을 pool에서 하나 가져온다.\n// \t\t\tresult = await connection.query(query) || null;\t\t// query문의 결과 || null 값이 result에 들어간다.\n// \t\t} catch(err) {\n// \t\t\tnext(err);\n// \t\t} finally {\n// \t\t\t//pool.releaseConnection(connection);\t\t\t\t\t\t\t\t// waterfall 에서는 connection.release()를 사용했지만, 이 경우 pool.releaseConnection(connection) 을 해준다.\n// console.log(connection);\n// \t\t\treturn result;\n// \t\t}\n\n// \t},\n// \tqueryParam_Arr : async (...args) => {\n// \t\tconst query = args[0];\n// \t\tconst value = args[1];\t// array\n// \t\tlet result;\n\n// \t\ttry {\n// \t\t\tvar connection = await pool.getConnection();\t\t\t// connection을 pool에서 하나 가져온다.\n// \t\t\tresult = await connection.query(query, value) || null;\t// 두 번째 parameter에 배열 => query문에 들어갈 runtime 시 결정될 value\n// \t\t} catch(err) {\n// \t\t\tnext(err);\n// \t\t\t//print(\"aaaaaaaaa\");\n// \t\t} finally {\n// \t\t\tpool.releaseConnection(connection);\t\t\t\t\t\t\t\t// waterfall 에서는 connection.release()를 사용했지만, 이 경우 pool.releaseConnection(connection) 을 해준다.\n// \t\t\treturn result;\n// \t\t}\n// \t}\n// };\n"]},"metadata":{},"sourceType":"module"}