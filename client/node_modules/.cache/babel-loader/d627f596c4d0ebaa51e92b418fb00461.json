{"ast":null,"code":"var _jsxFileName = \"/Users/seojin-won/wisdom-x-wisdom/client/src/containers/MediaContainer.js\";\nimport React, { Component } from 'react';\nimport { PropTypes } from 'prop-types';\nimport { getDisplayStream } from './media-access';\n\nclass MediaBridge extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      bridge: '',\n      user: ''\n    };\n    this.onRemoteHangup = this.onRemoteHangup.bind(this);\n    this.onMessage = this.onMessage.bind(this);\n    this.sendData = this.sendData.bind(this);\n    this.setupDataHandlers = this.setupDataHandlers.bind(this);\n    this.setDescription = this.setDescription.bind(this);\n    this.sendDescription = this.sendDescription.bind(this);\n    this.hangup = this.hangup.bind(this);\n    this.init = this.init.bind(this);\n    this.setDescription = this.setDescription.bind(this);\n  }\n\n  componentWillMount() {\n    // chrome polyfill for connection between the local device and a remote peer\n    window.RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection;\n    this.props.media(this);\n  }\n\n  componentDidMount() {\n    this.props.getUserMedia.then(stream => this.localVideo.srcObject = this.localStream = stream);\n    this.props.socket.on('message', this.onMessage);\n    this.props.socket.on('hangup', this.onRemoteHangup);\n  }\n\n  componentWillUnmount() {\n    this.props.media(null);\n\n    if (this.localStream !== undefined) {\n      this.localStream.getVideoTracks()[0].stop();\n    }\n\n    this.props.socket.emit('leave');\n  }\n\n  onRemoteHangup() {\n    this.setState({\n      user: 'host',\n      bridge: 'host-hangup'\n    });\n  }\n\n  onMessage(message) {\n    if (message.type === 'offer') {\n      // set remote description and answer\n      this.pc.setRemoteDescription(new RTCSessionDescription(message));\n      this.pc.createAnswer().then(this.setDescription).then(this.sendDescription).catch(this.handleError); // An error occurred, so handle the failure to connect\n    } else if (message.type === 'answer') {\n      // set remote description\n      this.pc.setRemoteDescription(new RTCSessionDescription(message));\n    } else if (message.type === 'candidate') {\n      // add ice candidate\n      this.pc.addIceCandidate(new RTCIceCandidate({\n        sdpMLineIndex: message.mlineindex,\n        candidate: message.candidate\n      }));\n    }\n  }\n\n  sendData(msg) {\n    this.dc.send(JSON.stringify(msg));\n  } // Set up the data channel message handler\n\n\n  setupDataHandlers() {\n    this.dc.onmessage = e => {\n      var msg = JSON.parse(e.data);\n      console.log('received message over data channel:' + msg);\n    };\n\n    this.dc.onclose = () => {\n      this.remoteStream.getVideoTracks()[0].stop();\n      console.log('The Data Channel is Closed');\n    };\n  }\n\n  setDescription(offer) {\n    this.pc.setLocalDescription(offer);\n  } // send the offer to a server to be forwarded to the other peer\n\n\n  sendDescription() {\n    this.props.socket.send(this.pc.localDescription);\n  }\n\n  hangup() {\n    this.setState({\n      user: 'guest',\n      bridge: 'guest-hangup'\n    });\n    this.pc.close();\n    this.props.socket.emit('leave');\n  }\n\n  handleError(e) {\n    console.log(e);\n  }\n\n  getDisplay() {\n    console.log(111111);\n    getDisplayStream().then(stream => {\n      stream.oninactive = () => {\n        this.pc.removeStream(this.localStream);\n        this.getUserMedia().then(() => {\n          this.pc.addStream(this.localStream);\n        });\n      }; // this.setState({ streamUrl: stream, localStream: stream })\n\n\n      this.localVideo.srcObject = stream;\n      this.pc.addStream(stream);\n    });\n  }\n\n  init() {\n    // wait for local media to be ready\n    const attachMediaIfReady = () => {\n      this.dc = this.pc.createDataChannel('chat');\n      this.setupDataHandlers();\n      console.log('attachMediaIfReady');\n      this.pc.createOffer().then(this.setDescription).then(this.sendDescription).catch(this.handleError); // An error occurred, so handle the failure to connect\n    }; // set up the peer connection\n    // this is one of Google's public STUN servers\n    // make sure your offer/answer role does not change. If user A does a SLD\n    // with type=offer initially, it must do that during  the whole session\n\n\n    this.pc = new RTCPeerConnection({\n      iceServers: [{\n        url: 'stun:stun.l.google.com:19302'\n      }]\n    }); // when our browser gets a candidate, send it to the peer\n\n    this.pc.onicecandidate = e => {\n      console.log(e, 'onicecandidate');\n\n      if (e.candidate) {\n        this.props.socket.send({\n          type: 'candidate',\n          mlineindex: e.candidate.sdpMLineIndex,\n          candidate: e.candidate.candidate\n        });\n      }\n    }; // when the other side added a media stream, show it on screen\n\n\n    this.pc.onaddstream = e => {\n      console.log('onaddstream', e);\n      this.remoteStream = e.stream;\n      this.remoteVideo.srcObject = this.remoteStream = e.stream;\n      this.setState({\n        bridge: 'established'\n      });\n    };\n\n    this.pc.ondatachannel = e => {\n      // data channel\n      this.dc = e.channel;\n      this.setupDataHandlers();\n      this.sendData({\n        peerMediaStream: {\n          video: this.localStream.getVideoTracks()[0].enabled\n        }\n      }); //sendData('hello');\n    }; // attach local media to the peer connection\n\n\n    this.localStream.getTracks().forEach(track => this.pc.addTrack(track, this.localStream)); // call if we were the last to connect (to increase\n    // chances that everything is set up properly at both ends)\n\n    if (this.state.user === 'host') {\n      this.props.getUserMedia.then(attachMediaIfReady);\n    }\n  }\n\n  render() {\n    return React.createElement(\"div\", {\n      className: \"media-bridge \".concat(this.state.bridge),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 163\n      },\n      __self: this\n    }, React.createElement(\"video\", {\n      className: \"remote-video\",\n      ref: ref => this.remoteVideo = ref,\n      autoPlay: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 164\n      },\n      __self: this\n    }), React.createElement(\"video\", {\n      className: \"local-video\",\n      ref: ref => this.localVideo = ref,\n      autoPlay: true,\n      muted: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 165\n      },\n      __self: this\n    }));\n  }\n\n}\n\nMediaBridge.propTypes = {\n  socket: PropTypes.object.isRequired,\n  getUserMedia: PropTypes.object.isRequired,\n  media: PropTypes.func.isRequired\n};\nexport default MediaBridge;","map":{"version":3,"sources":["/Users/seojin-won/wisdom-x-wisdom/client/src/containers/MediaContainer.js"],"names":["React","Component","PropTypes","getDisplayStream","MediaBridge","constructor","props","state","bridge","user","onRemoteHangup","bind","onMessage","sendData","setupDataHandlers","setDescription","sendDescription","hangup","init","componentWillMount","window","RTCPeerConnection","webkitRTCPeerConnection","media","componentDidMount","getUserMedia","then","stream","localVideo","srcObject","localStream","socket","on","componentWillUnmount","undefined","getVideoTracks","stop","emit","setState","message","type","pc","setRemoteDescription","RTCSessionDescription","createAnswer","catch","handleError","addIceCandidate","RTCIceCandidate","sdpMLineIndex","mlineindex","candidate","msg","dc","send","JSON","stringify","onmessage","e","parse","data","console","log","onclose","remoteStream","offer","setLocalDescription","localDescription","close","getDisplay","oninactive","removeStream","addStream","attachMediaIfReady","createDataChannel","createOffer","iceServers","url","onicecandidate","onaddstream","remoteVideo","ondatachannel","channel","peerMediaStream","video","enabled","getTracks","forEach","track","addTrack","render","ref","propTypes","object","isRequired","func"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SAASC,SAAT,QAA0B,YAA1B;AACA,SAAQC,gBAAR,QAA+B,gBAA/B;;AAEA,MAAMC,WAAN,SAA0BH,SAA1B,CAAoC;AAClCI,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,UAAMA,KAAN;AACA,SAAKC,KAAL,GAAa;AACXC,MAAAA,MAAM,EAAE,EADG;AAEXC,MAAAA,IAAI,EAAE;AAFK,KAAb;AAIA,SAAKC,cAAL,GAAsB,KAAKA,cAAL,CAAoBC,IAApB,CAAyB,IAAzB,CAAtB;AACA,SAAKC,SAAL,GAAiB,KAAKA,SAAL,CAAeD,IAAf,CAAoB,IAApB,CAAjB;AACA,SAAKE,QAAL,GAAgB,KAAKA,QAAL,CAAcF,IAAd,CAAmB,IAAnB,CAAhB;AACA,SAAKG,iBAAL,GAAyB,KAAKA,iBAAL,CAAuBH,IAAvB,CAA4B,IAA5B,CAAzB;AACA,SAAKI,cAAL,GAAsB,KAAKA,cAAL,CAAoBJ,IAApB,CAAyB,IAAzB,CAAtB;AACA,SAAKK,eAAL,GAAuB,KAAKA,eAAL,CAAqBL,IAArB,CAA0B,IAA1B,CAAvB;AACA,SAAKM,MAAL,GAAc,KAAKA,MAAL,CAAYN,IAAZ,CAAiB,IAAjB,CAAd;AACA,SAAKO,IAAL,GAAY,KAAKA,IAAL,CAAUP,IAAV,CAAe,IAAf,CAAZ;AACA,SAAKI,cAAL,GAAsB,KAAKA,cAAL,CAAoBJ,IAApB,CAAyB,IAAzB,CAAtB;AACD;;AACDQ,EAAAA,kBAAkB,GAAG;AACnB;AACAC,IAAAA,MAAM,CAACC,iBAAP,GAA2BD,MAAM,CAACC,iBAAP,IAA4BD,MAAM,CAACE,uBAA9D;AACA,SAAKhB,KAAL,CAAWiB,KAAX,CAAiB,IAAjB;AACD;;AACDC,EAAAA,iBAAiB,GAAG;AAClB,SAAKlB,KAAL,CAAWmB,YAAX,CACGC,IADH,CACQC,MAAM,IAAI,KAAKC,UAAL,CAAgBC,SAAhB,GAA4B,KAAKC,WAAL,GAAmBH,MADjE;AAEA,SAAKrB,KAAL,CAAWyB,MAAX,CAAkBC,EAAlB,CAAqB,SAArB,EAAgC,KAAKpB,SAArC;AACA,SAAKN,KAAL,CAAWyB,MAAX,CAAkBC,EAAlB,CAAqB,QAArB,EAA+B,KAAKtB,cAApC;AACD;;AACDuB,EAAAA,oBAAoB,GAAG;AACrB,SAAK3B,KAAL,CAAWiB,KAAX,CAAiB,IAAjB;;AACA,QAAI,KAAKO,WAAL,KAAqBI,SAAzB,EAAoC;AAClC,WAAKJ,WAAL,CAAiBK,cAAjB,GAAkC,CAAlC,EAAqCC,IAArC;AACD;;AACD,SAAK9B,KAAL,CAAWyB,MAAX,CAAkBM,IAAlB,CAAuB,OAAvB;AACD;;AACD3B,EAAAA,cAAc,GAAG;AACf,SAAK4B,QAAL,CAAc;AAAC7B,MAAAA,IAAI,EAAE,MAAP;AAAeD,MAAAA,MAAM,EAAE;AAAvB,KAAd;AACD;;AACDI,EAAAA,SAAS,CAAC2B,OAAD,EAAU;AACf,QAAIA,OAAO,CAACC,IAAR,KAAiB,OAArB,EAA8B;AAC1B;AACA,WAAKC,EAAL,CAAQC,oBAAR,CAA6B,IAAIC,qBAAJ,CAA0BJ,OAA1B,CAA7B;AACA,WAAKE,EAAL,CAAQG,YAAR,GACGlB,IADH,CACQ,KAAKX,cADb,EAEGW,IAFH,CAEQ,KAAKV,eAFb,EAGG6B,KAHH,CAGS,KAAKC,WAHd,EAH0B,CAME;AAE/B,KARD,MAQO,IAAIP,OAAO,CAACC,IAAR,KAAiB,QAArB,EAA+B;AAClC;AACA,WAAKC,EAAL,CAAQC,oBAAR,CAA6B,IAAIC,qBAAJ,CAA0BJ,OAA1B,CAA7B;AACH,KAHM,MAGA,IAAIA,OAAO,CAACC,IAAR,KAAiB,WAArB,EAAkC;AACrC;AACA,WAAKC,EAAL,CAAQM,eAAR,CACI,IAAIC,eAAJ,CAAoB;AAChBC,QAAAA,aAAa,EAAEV,OAAO,CAACW,UADP;AAEhBC,QAAAA,SAAS,EAAEZ,OAAO,CAACY;AAFH,OAApB,CADJ;AAMH;AACJ;;AACDtC,EAAAA,QAAQ,CAACuC,GAAD,EAAM;AACZ,SAAKC,EAAL,CAAQC,IAAR,CAAaC,IAAI,CAACC,SAAL,CAAeJ,GAAf,CAAb;AACD,GA9DiC,CA+DlC;;;AACAtC,EAAAA,iBAAiB,GAAG;AAChB,SAAKuC,EAAL,CAAQI,SAAR,GAAoBC,CAAC,IAAI;AACrB,UAAIN,GAAG,GAAGG,IAAI,CAACI,KAAL,CAAWD,CAAC,CAACE,IAAb,CAAV;AACAC,MAAAA,OAAO,CAACC,GAAR,CAAY,wCAAwCV,GAApD;AACH,KAHD;;AAIA,SAAKC,EAAL,CAAQU,OAAR,GAAkB,MAAM;AACtB,WAAKC,YAAL,CAAkB7B,cAAlB,GAAmC,CAAnC,EAAsCC,IAAtC;AACAyB,MAAAA,OAAO,CAACC,GAAR,CAAY,4BAAZ;AACD,KAHD;AAIH;;AACD/C,EAAAA,cAAc,CAACkD,KAAD,EAAQ;AACpB,SAAKxB,EAAL,CAAQyB,mBAAR,CAA4BD,KAA5B;AACD,GA5EiC,CA6ElC;;;AACAjD,EAAAA,eAAe,GAAG;AAChB,SAAKV,KAAL,CAAWyB,MAAX,CAAkBuB,IAAlB,CAAuB,KAAKb,EAAL,CAAQ0B,gBAA/B;AACD;;AACDlD,EAAAA,MAAM,GAAG;AACP,SAAKqB,QAAL,CAAc;AAAC7B,MAAAA,IAAI,EAAE,OAAP;AAAgBD,MAAAA,MAAM,EAAE;AAAxB,KAAd;AACA,SAAKiC,EAAL,CAAQ2B,KAAR;AACA,SAAK9D,KAAL,CAAWyB,MAAX,CAAkBM,IAAlB,CAAuB,OAAvB;AACD;;AACDS,EAAAA,WAAW,CAACY,CAAD,EAAI;AACbG,IAAAA,OAAO,CAACC,GAAR,CAAYJ,CAAZ;AACD;;AACDW,EAAAA,UAAU,GAAE;AACVR,IAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ;AACA3D,IAAAA,gBAAgB,GAAGuB,IAAnB,CAAwBC,MAAM,IAAI;AAChCA,MAAAA,MAAM,CAAC2C,UAAP,GAAoB,MAAM;AACxB,aAAK7B,EAAL,CAAQ8B,YAAR,CAAqB,KAAKzC,WAA1B;AACA,aAAKL,YAAL,GAAoBC,IAApB,CAAyB,MAAM;AAC7B,eAAKe,EAAL,CAAQ+B,SAAR,CAAkB,KAAK1C,WAAvB;AACD,SAFD;AAGD,OALD,CADgC,CAOhC;;;AACA,WAAKF,UAAL,CAAgBC,SAAhB,GAA4BF,MAA5B;AACA,WAAKc,EAAL,CAAQ+B,SAAR,CAAkB7C,MAAlB;AACD,KAVD;AAWD;;AACDT,EAAAA,IAAI,GAAG;AACL;AACA,UAAMuD,kBAAkB,GAAG,MAAM;AAC/B,WAAKpB,EAAL,GAAU,KAAKZ,EAAL,CAAQiC,iBAAR,CAA0B,MAA1B,CAAV;AACA,WAAK5D,iBAAL;AACA+C,MAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ;AACA,WAAKrB,EAAL,CAAQkC,WAAR,GACGjD,IADH,CACQ,KAAKX,cADb,EAEGW,IAFH,CAEQ,KAAKV,eAFb,EAGG6B,KAHH,CAGS,KAAKC,WAHd,EAJ+B,CAOH;AAC7B,KARD,CAFK,CAWL;AACA;AACA;AACA;;;AACA,SAAKL,EAAL,GAAU,IAAIpB,iBAAJ,CAAsB;AAACuD,MAAAA,UAAU,EAAE,CAAC;AAACC,QAAAA,GAAG,EAAE;AAAN,OAAD;AAAb,KAAtB,CAAV,CAfK,CAgBL;;AACA,SAAKpC,EAAL,CAAQqC,cAAR,GAAyBpB,CAAC,IAAI;AAC1BG,MAAAA,OAAO,CAACC,GAAR,CAAYJ,CAAZ,EAAe,gBAAf;;AACA,UAAIA,CAAC,CAACP,SAAN,EAAiB;AACb,aAAK7C,KAAL,CAAWyB,MAAX,CAAkBuB,IAAlB,CAAuB;AACnBd,UAAAA,IAAI,EAAE,WADa;AAEnBU,UAAAA,UAAU,EAAEQ,CAAC,CAACP,SAAF,CAAYF,aAFL;AAGnBE,UAAAA,SAAS,EAAEO,CAAC,CAACP,SAAF,CAAYA;AAHJ,SAAvB;AAKH;AACJ,KATD,CAjBK,CA2BL;;;AACA,SAAKV,EAAL,CAAQsC,WAAR,GAAsBrB,CAAC,IAAI;AACvBG,MAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ,EAA2BJ,CAA3B;AACA,WAAKM,YAAL,GAAoBN,CAAC,CAAC/B,MAAtB;AACA,WAAKqD,WAAL,CAAiBnD,SAAjB,GAA6B,KAAKmC,YAAL,GAAoBN,CAAC,CAAC/B,MAAnD;AACA,WAAKW,QAAL,CAAc;AAAC9B,QAAAA,MAAM,EAAE;AAAT,OAAd;AACH,KALD;;AAMA,SAAKiC,EAAL,CAAQwC,aAAR,GAAwBvB,CAAC,IAAI;AACzB;AACA,WAAKL,EAAL,GAAUK,CAAC,CAACwB,OAAZ;AACA,WAAKpE,iBAAL;AACA,WAAKD,QAAL,CAAc;AACZsE,QAAAA,eAAe,EAAE;AACfC,UAAAA,KAAK,EAAE,KAAKtD,WAAL,CAAiBK,cAAjB,GAAkC,CAAlC,EAAqCkD;AAD7B;AADL,OAAd,EAJyB,CASzB;AACH,KAVD,CAlCK,CA6CL;;;AACA,SAAKvD,WAAL,CAAiBwD,SAAjB,GAA6BC,OAA7B,CAAqCC,KAAK,IAAI,KAAK/C,EAAL,CAAQgD,QAAR,CAAiBD,KAAjB,EAAwB,KAAK1D,WAA7B,CAA9C,EA9CK,CA+CL;AACA;;AACA,QAAI,KAAKvB,KAAL,CAAWE,IAAX,KAAoB,MAAxB,EAAgC;AAC9B,WAAKH,KAAL,CAAWmB,YAAX,CAAwBC,IAAxB,CAA6B+C,kBAA7B;AACD;AACF;;AACDiB,EAAAA,MAAM,GAAE;AACN,WACE;AAAK,MAAA,SAAS,yBAAkB,KAAKnF,KAAL,CAAWC,MAA7B,CAAd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACE;AAAO,MAAA,SAAS,EAAC,cAAjB;AAAgC,MAAA,GAAG,EAAGmF,GAAD,IAAS,KAAKX,WAAL,GAAmBW,GAAjE;AAAsE,MAAA,QAAQ,MAA9E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADF,EAEE;AAAO,MAAA,SAAS,EAAC,aAAjB;AAA+B,MAAA,GAAG,EAAGA,GAAD,IAAS,KAAK/D,UAAL,GAAkB+D,GAA/D;AAAoE,MAAA,QAAQ,MAA5E;AAA6E,MAAA,KAAK,MAAlF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAFF,CADF;AAMD;;AAnKiC;;AAqKpCvF,WAAW,CAACwF,SAAZ,GAAwB;AACtB7D,EAAAA,MAAM,EAAE7B,SAAS,CAAC2F,MAAV,CAAiBC,UADH;AAEtBrE,EAAAA,YAAY,EAAEvB,SAAS,CAAC2F,MAAV,CAAiBC,UAFT;AAGtBvE,EAAAA,KAAK,EAAErB,SAAS,CAAC6F,IAAV,CAAeD;AAHA,CAAxB;AAKA,eAAe1F,WAAf","sourcesContent":["import React, { Component } from 'react';\nimport { PropTypes } from 'prop-types';\nimport {getDisplayStream} from './media-access'\n\nclass MediaBridge extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      bridge: '',\n      user: ''\n    }\n    this.onRemoteHangup = this.onRemoteHangup.bind(this);\n    this.onMessage = this.onMessage.bind(this);\n    this.sendData = this.sendData.bind(this);\n    this.setupDataHandlers = this.setupDataHandlers.bind(this);\n    this.setDescription = this.setDescription.bind(this);\n    this.sendDescription = this.sendDescription.bind(this);\n    this.hangup = this.hangup.bind(this);\n    this.init = this.init.bind(this);\n    this.setDescription = this.setDescription.bind(this);\n  }\n  componentWillMount() {\n    // chrome polyfill for connection between the local device and a remote peer\n    window.RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection;\n    this.props.media(this);\n  }\n  componentDidMount() {\n    this.props.getUserMedia\n      .then(stream => this.localVideo.srcObject = this.localStream = stream);\n    this.props.socket.on('message', this.onMessage);\n    this.props.socket.on('hangup', this.onRemoteHangup);\n  }\n  componentWillUnmount() {\n    this.props.media(null);\n    if (this.localStream !== undefined) {\n      this.localStream.getVideoTracks()[0].stop();\n    }\n    this.props.socket.emit('leave');\n  }\n  onRemoteHangup() {\n    this.setState({user: 'host', bridge: 'host-hangup'});\n  }\n  onMessage(message) {\n      if (message.type === 'offer') {\n          // set remote description and answer\n          this.pc.setRemoteDescription(new RTCSessionDescription(message));\n          this.pc.createAnswer()\n            .then(this.setDescription)\n            .then(this.sendDescription)\n            .catch(this.handleError); // An error occurred, so handle the failure to connect\n\n      } else if (message.type === 'answer') {\n          // set remote description\n          this.pc.setRemoteDescription(new RTCSessionDescription(message));\n      } else if (message.type === 'candidate') {\n          // add ice candidate\n          this.pc.addIceCandidate(\n              new RTCIceCandidate({\n                  sdpMLineIndex: message.mlineindex,\n                  candidate: message.candidate\n              })\n          );\n      }\n  }\n  sendData(msg) {\n    this.dc.send(JSON.stringify(msg))\n  }\n  // Set up the data channel message handler\n  setupDataHandlers() {\n      this.dc.onmessage = e => {\n          var msg = JSON.parse(e.data);\n          console.log('received message over data channel:' + msg);\n      };\n      this.dc.onclose = () => {\n        this.remoteStream.getVideoTracks()[0].stop();\n        console.log('The Data Channel is Closed');\n      };\n  }\n  setDescription(offer) {\n    this.pc.setLocalDescription(offer);\n  }\n  // send the offer to a server to be forwarded to the other peer\n  sendDescription() {\n    this.props.socket.send(this.pc.localDescription);\n  }\n  hangup() {\n    this.setState({user: 'guest', bridge: 'guest-hangup'});\n    this.pc.close();\n    this.props.socket.emit('leave');\n  }\n  handleError(e) {\n    console.log(e);\n  }\n  getDisplay(){\n    console.log(111111)\n    getDisplayStream().then(stream => {\n      stream.oninactive = () => {\n        this.pc.removeStream(this.localStream)  \n        this.getUserMedia().then(() => {\n          this.pc.addStream(this.localStream)\n        })\n      }\n      // this.setState({ streamUrl: stream, localStream: stream })\n      this.localVideo.srcObject = stream   \n      this.pc.addStream(stream)   \n    })\n  }\n  init() {\n    // wait for local media to be ready\n    const attachMediaIfReady = () => {\n      this.dc = this.pc.createDataChannel('chat');\n      this.setupDataHandlers();\n      console.log('attachMediaIfReady')\n      this.pc.createOffer()\n        .then(this.setDescription)\n        .then(this.sendDescription)\n        .catch(this.handleError); // An error occurred, so handle the failure to connect\n    }\n    // set up the peer connection\n    // this is one of Google's public STUN servers\n    // make sure your offer/answer role does not change. If user A does a SLD\n    // with type=offer initially, it must do that during  the whole session\n    this.pc = new RTCPeerConnection({iceServers: [{url: 'stun:stun.l.google.com:19302'}]});\n    // when our browser gets a candidate, send it to the peer\n    this.pc.onicecandidate = e => {\n        console.log(e, 'onicecandidate');\n        if (e.candidate) {\n            this.props.socket.send({\n                type: 'candidate',\n                mlineindex: e.candidate.sdpMLineIndex,\n                candidate: e.candidate.candidate\n            });\n        }\n    };\n    // when the other side added a media stream, show it on screen\n    this.pc.onaddstream = e => {\n        console.log('onaddstream', e) \n        this.remoteStream = e.stream;\n        this.remoteVideo.srcObject = this.remoteStream = e.stream;\n        this.setState({bridge: 'established'});\n    };\n    this.pc.ondatachannel = e => {\n        // data channel\n        this.dc = e.channel;\n        this.setupDataHandlers();\n        this.sendData({\n          peerMediaStream: {\n            video: this.localStream.getVideoTracks()[0].enabled\n          }\n        });\n        //sendData('hello');\n    };\n    // attach local media to the peer connection\n    this.localStream.getTracks().forEach(track => this.pc.addTrack(track, this.localStream));\n    // call if we were the last to connect (to increase\n    // chances that everything is set up properly at both ends)\n    if (this.state.user === 'host') {\n      this.props.getUserMedia.then(attachMediaIfReady);\n    }  \n  }\n  render(){\n    return (\n      <div className={`media-bridge ${this.state.bridge}`}>\n        <video className=\"remote-video\" ref={(ref) => this.remoteVideo = ref} autoPlay></video>\n        <video className=\"local-video\" ref={(ref) => this.localVideo = ref} autoPlay muted></video>\n      </div>\n    );\n  }\n}\nMediaBridge.propTypes = {\n  socket: PropTypes.object.isRequired,\n  getUserMedia: PropTypes.object.isRequired,\n  media: PropTypes.func.isRequired\n}\nexport default MediaBridge;"]},"metadata":{},"sourceType":"module"}