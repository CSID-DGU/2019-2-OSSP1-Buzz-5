{"ast":null,"code":"var _jsxFileName = \"/Users/seojin-won/wisdom-x-wisdom/client/src/containers/MediaContainer.js\";\nimport React, { Component } from 'react';\nimport { PropTypes } from 'prop-types';\nimport { getDisplayStream } from './media-access';\n\nclass MediaBridge extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      bridge: '',\n      user: ''\n    };\n    this.onRemoteHangup = this.onRemoteHangup.bind(this);\n    this.onMessage = this.onMessage.bind(this);\n    this.sendData = this.sendData.bind(this);\n    this.setupDataHandlers = this.setupDataHandlers.bind(this);\n    this.setDescription = this.setDescription.bind(this);\n    this.sendDescription = this.sendDescription.bind(this);\n    this.hangup = this.hangup.bind(this);\n    this.init = this.init.bind(this);\n    this.setDescription = this.setDescription.bind(this);\n    this.getDisplay = this.getDisplay.bind(this);\n  }\n\n  componentWillMount() {\n    // chrome polyfill for connection between the local device and a remote peer\n    window.RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection;\n    this.props.media(this);\n  }\n\n  componentDidMount() {\n    this.props.getUserMedia.then(stream => this.localVideo.srcObject = this.localStream = stream);\n    this.props.socket.on('message', this.onMessage);\n    this.props.socket.on('hangup', this.onRemoteHangup);\n  }\n\n  componentWillUnmount() {\n    this.props.media(null);\n\n    if (this.localStream !== undefined) {\n      this.localStream.getVideoTracks()[0].stop();\n    }\n\n    this.props.socket.emit('leave');\n  }\n\n  onRemoteHangup() {\n    this.setState({\n      user: 'host',\n      bridge: 'host-hangup'\n    });\n  }\n\n  onMessage(message) {\n    if (message.type === 'offer') {\n      // set remote description and answer\n      this.pc.setRemoteDescription(new RTCSessionDescription(message));\n      this.pc.createAnswer().then(this.setDescription).then(this.sendDescription).catch(this.handleError); // An error occurred, so handle the failure to connect\n    } else if (message.type === 'answer') {\n      // set remote description\n      this.pc.setRemoteDescription(new RTCSessionDescription(message));\n    } else if (message.type === 'candidate') {\n      // add ice candidate\n      this.pc.addIceCandidate(new RTCIceCandidate({\n        sdpMLineIndex: message.mlineindex,\n        candidate: message.candidate\n      }));\n    }\n  }\n\n  sendData(msg) {\n    this.dc.send(JSON.stringify(msg));\n  } // Set up the data channel message handler\n\n\n  setupDataHandlers() {\n    this.dc.onmessage = e => {\n      var msg = JSON.parse(e.data);\n      console.log('received message over data channel:' + msg);\n    };\n\n    this.dc.onclose = () => {\n      this.remoteStream.getVideoTracks()[0].stop();\n      console.log('The Data Channel is Closed');\n    };\n  }\n\n  setDescription(offer) {\n    this.pc.setLocalDescription(offer);\n  } // send the offer to a server to be forwarded to the other peer\n\n\n  sendDescription() {\n    this.props.socket.send(this.pc.localDescription);\n  }\n\n  hangup() {\n    this.setState({\n      user: 'guest',\n      bridge: 'guest-hangup'\n    });\n    this.pc.close();\n    this.props.socket.emit('leave');\n  }\n\n  handleError(e) {\n    console.log(e);\n  }\n\n  getUserMedia(cb) {\n    return new Promise((resolve, reject) => {\n      navigator.getUserMedia = navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\n      const op = {\n        video: {\n          width: {\n            min: 160,\n            ideal: 640,\n            max: 1280\n          },\n          height: {\n            min: 120,\n            ideal: 360,\n            max: 720\n          }\n        },\n        audio: true\n      };\n      navigator.getUserMedia(op, stream => {\n        // this.setState({ streamUrl: stream, localStream: stream })\n        this.localVideo.srcObject = stream;\n        resolve();\n      }, () => {});\n    });\n  } // getDisplay(){\n  //   getDisplayStream().then(stream => {\n  //     stream.oninactive = () => {\n  //       this.pc.removeStream(this.localStream)  \n  //       this.props.getUserMedia.then(() => {\n  //         this.pc.addStream(this.localStream)\n  //       })\n  //     }\n  //     // this.setState({ streamUrl: stream, localStream: stream })\n  //     this.localVideo.srcObject = stream\n  //     this.pc.addStream(stream)   \n  //   })\n  // }\n\n\n  async getDisplay() {\n    try {\n      console.log(1111111);\n      await navigator.mediaDevices.getDisplayMedia().then(stream => {\n        console.log(22222222);\n\n        stream.oninactive = () => {\n          this.pc.removeTrack(this.localStream);\n          this.props.getUserMedia.then(() => {\n            this.pc.addTrack(this.localStream);\n          });\n        }; // this.setState({ streamUrl: stream, localStream: stream })\n\n\n        this.localVideo.srcObject = stream;\n        this.pc.addTrack(stream);\n      });\n    } catch (err) {\n      console.log(err);\n    }\n  }\n\n  init() {\n    // wait for local media to be ready\n    const attachMediaIfReady = () => {\n      this.dc = this.pc.createDataChannel('chat');\n      this.setupDataHandlers();\n      console.log('attachMediaIfReady');\n      this.pc.createOffer().then(this.setDescription).then(this.sendDescription).catch(this.handleError); // An error occurred, so handle the failure to connect\n    }; // set up the peer connection\n    // this is one of Google's public STUN servers\n    // make sure your offer/answer role does not change. If user A does a SLD\n    // with type=offer initially, it must do that during  the whole session\n\n\n    this.pc = new RTCPeerConnection({\n      iceServers: [{\n        url: 'stun:stun.l.google.com:19302'\n      }]\n    }); // when our browser gets a candidate, send it to the peer\n\n    this.pc.onicecandidate = e => {\n      console.log(e, 'onicecandidate');\n\n      if (e.candidate) {\n        this.props.socket.send({\n          type: 'candidate',\n          mlineindex: e.candidate.sdpMLineIndex,\n          candidate: e.candidate.candidate\n        });\n      }\n    }; // when the other side added a media stream, show it on screen\n\n\n    this.pc.onaddstream = e => {\n      console.log('onaddstream', e);\n      this.remoteStream = e.stream;\n      this.remoteVideo.srcObject = this.remoteStream = e.stream;\n      this.setState({\n        bridge: 'established'\n      });\n    };\n\n    this.pc.ondatachannel = e => {\n      // data channel\n      this.dc = e.channel;\n      this.setupDataHandlers();\n      this.sendData({\n        peerMediaStream: {\n          video: this.localStream.getVideoTracks()[0].enabled\n        }\n      }); //sendData('hello');\n    }; // attach local media to the peer connection\n\n\n    this.localStream.getTracks().forEach(track => this.pc.addTrack(track, this.localStream)); // call if we were the last to connect (to increase\n    // chances that everything is set up properly at both ends)\n\n    if (this.state.user === 'host') {\n      this.props.getUserMedia.then(attachMediaIfReady);\n    }\n  }\n\n  render() {\n    return React.createElement(\"div\", {\n      className: \"container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 210\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      className: \"media-bridge \".concat(this.state.bridge),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 211\n      },\n      __self: this\n    }, React.createElement(\"video\", {\n      className: \"remote-video\",\n      ref: ref => this.remoteVideo = ref,\n      autoPlay: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 212\n      },\n      __self: this\n    }), React.createElement(\"video\", {\n      className: \"local-video\",\n      ref: ref => this.localVideo = ref,\n      autoPlay: true,\n      muted: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 213\n      },\n      __self: this\n    })));\n  }\n\n}\n\nMediaBridge.propTypes = {\n  socket: PropTypes.object.isRequired,\n  getUserMedia: PropTypes.object.isRequired,\n  media: PropTypes.func.isRequired\n};\nexport default MediaBridge;","map":{"version":3,"sources":["/Users/seojin-won/wisdom-x-wisdom/client/src/containers/MediaContainer.js"],"names":["React","Component","PropTypes","getDisplayStream","MediaBridge","constructor","props","state","bridge","user","onRemoteHangup","bind","onMessage","sendData","setupDataHandlers","setDescription","sendDescription","hangup","init","getDisplay","componentWillMount","window","RTCPeerConnection","webkitRTCPeerConnection","media","componentDidMount","getUserMedia","then","stream","localVideo","srcObject","localStream","socket","on","componentWillUnmount","undefined","getVideoTracks","stop","emit","setState","message","type","pc","setRemoteDescription","RTCSessionDescription","createAnswer","catch","handleError","addIceCandidate","RTCIceCandidate","sdpMLineIndex","mlineindex","candidate","msg","dc","send","JSON","stringify","onmessage","e","parse","data","console","log","onclose","remoteStream","offer","setLocalDescription","localDescription","close","cb","Promise","resolve","reject","navigator","webkitGetUserMedia","mozGetUserMedia","op","video","width","min","ideal","max","height","audio","mediaDevices","getDisplayMedia","oninactive","removeTrack","addTrack","err","attachMediaIfReady","createDataChannel","createOffer","iceServers","url","onicecandidate","onaddstream","remoteVideo","ondatachannel","channel","peerMediaStream","enabled","getTracks","forEach","track","render","ref","propTypes","object","isRequired","func"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { PropTypes } from 'prop-types';\nimport {getDisplayStream} from './media-access'\n\nclass MediaBridge extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      bridge: '',\n      user: ''\n    }\n    this.onRemoteHangup = this.onRemoteHangup.bind(this);\n    this.onMessage = this.onMessage.bind(this);\n    this.sendData = this.sendData.bind(this);\n    this.setupDataHandlers = this.setupDataHandlers.bind(this);\n    this.setDescription = this.setDescription.bind(this);\n    this.sendDescription = this.sendDescription.bind(this);\n    this.hangup = this.hangup.bind(this);\n    this.init = this.init.bind(this);\n    this.setDescription = this.setDescription.bind(this);\n    this.getDisplay = this.getDisplay.bind(this);\n  }\n  componentWillMount() {\n    // chrome polyfill for connection between the local device and a remote peer\n    window.RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection;\n    this.props.media(this);\n  }\n  componentDidMount() {\n    this.props.getUserMedia\n      .then(stream => this.localVideo.srcObject = this.localStream = stream);\n    this.props.socket.on('message', this.onMessage);\n    this.props.socket.on('hangup', this.onRemoteHangup);\n  }\n  componentWillUnmount() {\n    this.props.media(null);\n    if (this.localStream !== undefined) {\n      this.localStream.getVideoTracks()[0].stop();\n    }\n    this.props.socket.emit('leave');\n  }\n  onRemoteHangup() {\n    this.setState({user: 'host', bridge: 'host-hangup'});\n  }\n  onMessage(message) {\n      if (message.type === 'offer') {\n          // set remote description and answer\n          this.pc.setRemoteDescription(new RTCSessionDescription(message));\n          this.pc.createAnswer()\n            .then(this.setDescription)\n            .then(this.sendDescription)\n            .catch(this.handleError); // An error occurred, so handle the failure to connect\n\n      } else if (message.type === 'answer') {\n          // set remote description\n          this.pc.setRemoteDescription(new RTCSessionDescription(message));\n      } else if (message.type === 'candidate') {\n          // add ice candidate\n          this.pc.addIceCandidate(\n              new RTCIceCandidate({\n                  sdpMLineIndex: message.mlineindex,\n                  candidate: message.candidate\n              })\n          );\n      }\n  }\n  sendData(msg) {\n    this.dc.send(JSON.stringify(msg))\n  }\n  // Set up the data channel message handler\n  setupDataHandlers() {\n      this.dc.onmessage = e => {\n          var msg = JSON.parse(e.data);\n          console.log('received message over data channel:' + msg);\n      };\n      this.dc.onclose = () => {\n        this.remoteStream.getVideoTracks()[0].stop();\n        console.log('The Data Channel is Closed');\n      };\n  }\n  setDescription(offer) {\n    this.pc.setLocalDescription(offer);\n  }\n  // send the offer to a server to be forwarded to the other peer\n  sendDescription() {\n    this.props.socket.send(this.pc.localDescription);\n  }\n  hangup() {\n    this.setState({user: 'guest', bridge: 'guest-hangup'});\n    this.pc.close();\n    this.props.socket.emit('leave');\n  }\n  handleError(e) {\n    console.log(e);\n  }\n  \n  getUserMedia(cb) {\n    return new Promise((resolve, reject) => {\n      navigator.getUserMedia = navigator.getUserMedia =\n        navigator.getUserMedia ||\n        navigator.webkitGetUserMedia ||\n        navigator.mozGetUserMedia\n      const op = {\n        video: {\n          width: { min: 160, ideal: 640, max: 1280 },\n          height: { min: 120, ideal: 360, max: 720 }\n        },\n        audio: true\n      }\n      navigator.getUserMedia(\n        op,\n        stream => {\n          // this.setState({ streamUrl: stream, localStream: stream })\n          this.localVideo.srcObject = stream\n          resolve()\n        },\n        () => {}\n      )\n    })\n  }\n  \n  // getDisplay(){\n  //   getDisplayStream().then(stream => {\n  //     stream.oninactive = () => {\n  //       this.pc.removeStream(this.localStream)  \n  //       this.props.getUserMedia.then(() => {\n  //         this.pc.addStream(this.localStream)\n  //       })\n  //     }\n  //     // this.setState({ streamUrl: stream, localStream: stream })\n  //     this.localVideo.srcObject = stream\n  //     this.pc.addStream(stream)   \n  //   })\n  // }\n\n  async getDisplay() {\n    try {\n      console.log(1111111)\n      await navigator.mediaDevices.getDisplayMedia().then(stream => {\n          console.log(22222222)\n          stream.oninactive = () => {\n            this.pc.removeTrack(this.localStream)  \n            this.props.getUserMedia.then(() => {\n              this.pc.addTrack(this.localStream)\n            })\n        }\n        // this.setState({ streamUrl: stream, localStream: stream })\n        this.localVideo.srcObject = stream\n        this.pc.addTrack(stream)\n      })\n    } catch(err) {\n      console.log(err)\n    }\n  }\n\n  init() {\n    // wait for local media to be ready\n    const attachMediaIfReady = () => {\n      this.dc = this.pc.createDataChannel('chat');\n      this.setupDataHandlers();\n      console.log('attachMediaIfReady')\n      this.pc.createOffer()\n        .then(this.setDescription)\n        .then(this.sendDescription)\n        .catch(this.handleError); // An error occurred, so handle the failure to connect\n    }\n    // set up the peer connection\n    // this is one of Google's public STUN servers\n    // make sure your offer/answer role does not change. If user A does a SLD\n    // with type=offer initially, it must do that during  the whole session\n    this.pc = new RTCPeerConnection({iceServers: [{url: 'stun:stun.l.google.com:19302'}]});\n    // when our browser gets a candidate, send it to the peer\n    this.pc.onicecandidate = e => {\n        console.log(e, 'onicecandidate');\n        if (e.candidate) {\n            this.props.socket.send({\n                type: 'candidate',\n                mlineindex: e.candidate.sdpMLineIndex,\n                candidate: e.candidate.candidate\n            });\n        }\n    };\n    // when the other side added a media stream, show it on screen\n    this.pc.onaddstream = e => {\n        console.log('onaddstream', e) \n        this.remoteStream = e.stream;\n        this.remoteVideo.srcObject = this.remoteStream = e.stream;\n        this.setState({bridge: 'established'});\n    };\n    this.pc.ondatachannel = e => {\n        // data channel\n        this.dc = e.channel;\n        this.setupDataHandlers();\n        this.sendData({\n          peerMediaStream: {\n            video: this.localStream.getVideoTracks()[0].enabled\n          }\n        });\n        //sendData('hello');\n    };\n    // attach local media to the peer connection\n    this.localStream.getTracks().forEach(track => this.pc.addTrack(track, this.localStream));\n    // call if we were the last to connect (to increase\n    // chances that everything is set up properly at both ends)\n    if (this.state.user === 'host') {\n      this.props.getUserMedia.then(attachMediaIfReady);\n    }  \n  }\n  render(){\n    return (\n      <div className=\"container\">\n        <div className={`media-bridge ${this.state.bridge}`}>\n          <video className=\"remote-video\" ref={(ref) => this.remoteVideo = ref} autoPlay></video>\n          <video className=\"local-video\" ref={(ref) => this.localVideo = ref} autoPlay muted></video>\n        </div>\n      </div>\n    );\n  }\n}\nMediaBridge.propTypes = {\n  socket: PropTypes.object.isRequired,\n  getUserMedia: PropTypes.object.isRequired,\n  media: PropTypes.func.isRequired\n}\nexport default MediaBridge;"]},"metadata":{},"sourceType":"module"}