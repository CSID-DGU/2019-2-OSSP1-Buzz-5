{"ast":null,"code":"'use strict';\n\nconst Promise = require(\"bluebird\");\n\nconst mysql = require(\"mysql\");\n\nconst promiseCallback = require(\"./helper\").promiseCallback;\n\nclass connection {\n  constructor(config = {}, _connection) {\n    let mysqlValue = mysql;\n    let mysqlWrapperCallbackPromise;\n\n    if (config.mysqlWrapper) {\n      let callback;\n      mysqlWrapperCallbackPromise = new Promise((resolve, reject) => {\n        callback = (err, mysql) => {\n          if (err) {\n            return reject(err);\n          }\n\n          return resolve(mysql);\n        };\n      });\n      mysqlValue = config.mysqlWrapper(mysql, callback);\n      config.mysqlWrapper = undefined;\n    }\n\n    if (config.returnArgumentsArray) {\n      this.returnArgumentsArray = config.returnArgumentsArray;\n      config.returnArgumentsArray = undefined;\n    }\n\n    if (config.reconnect === true || config.reconnect === undefined) {\n      this.reconnect = true;\n      config.reconnect = undefined;\n    }\n\n    this.config = config;\n    return Promise.resolve(mysqlValue || mysqlWrapperCallbackPromise).then(mysql => {\n      if (_connection && this.reconnect) {\n        addReconnectHandler(_connection, mysql, this.config);\n      } else if (!_connection) {\n        _connection = connect(mysql, this.config, this.reconnect);\n      }\n\n      return _connection;\n    }).then(connection => {\n      this.connection = connection;\n      return this;\n    });\n  }\n\n  query() {\n    return promiseCallback.apply(this.connection, [\"query\", arguments, this.returnArgumentsArray]);\n  }\n\n  queryStream(sql, values) {\n    return this.connection.query(sql, values);\n  }\n\n  beginTransaction() {\n    return promiseCallback.apply(this.connection, [\"beginTransaction\", arguments, this.returnArgumentsArray]);\n  }\n\n  commit() {\n    return promiseCallback.apply(this.connection, [\"commit\", arguments, this.returnArgumentsArray]);\n  }\n\n  rollback() {\n    return promiseCallback.apply(this.connection, [\"rollback\", arguments, this.returnArgumentsArray]);\n  }\n\n  changeUser() {\n    return promiseCallback.apply(this.connection, [\"changeUser\", arguments, this.returnArgumentsArray]);\n  }\n\n  ping() {\n    return promiseCallback.apply(this.connection, [\"ping\", arguments, this.returnArgumentsArray]);\n  }\n\n  statistics() {\n    return promiseCallback.apply(this.connection, [\"statistics\", arguments, this.returnArgumentsArray]);\n  }\n\n  end() {\n    return promiseCallback.apply(this.connection, [\"end\", arguments, this.returnArgumentsArray]);\n  }\n\n  destroy() {\n    this.connection.destroy();\n  }\n\n  pause() {\n    this.connection.pause();\n  }\n\n  resume() {\n    this.connection.resume();\n  }\n\n  escape(value) {\n    return this.connection.escape(value);\n  }\n\n  escapeId(value) {\n    return this.connection.escapeId(value);\n  }\n\n  format(sql, values) {\n    return this.connection.format(sql, values);\n  }\n\n  on(event, fn) {\n    this.connection.on(event, fn);\n  }\n\n}\n\nconst connect = (mysql, config, reconnect) => {\n  const connection = mysql.createConnection(config);\n  return new Promise((resolve, reject) => {\n    connection.connect(err => {\n      if (err) {\n        return reject(err);\n      } else {\n        if (reconnect) {\n          addReconnectHandler(connection, mysql, config);\n        }\n\n        return resolve(connection);\n      }\n    });\n  });\n};\n\nconst addReconnectHandler = (connection, mysql, config) => {\n  connection.once(\"error\", err => {\n    if (err.code === \"PROTOCOL_CONNECTION_LOST\" || err.code === \"ECONNRESET\" || err.code === \"PROTOCOL_ENQUEUE_AFTER_FATAL_ERROR\") {\n      connect(mysql, config);\n    }\n  });\n};\n\nmodule.exports = connection;","map":null,"metadata":{},"sourceType":"script"}