{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\gksdb\\\\Desktop\\\\2019-2-OSSP1-Buzz-5\\\\client\\\\src\\\\containers\\\\MediaContainer.js\";\nimport React, { Component } from 'react';\nimport { PropTypes } from 'prop-types';\nimport { getDisplayStream } from './media-access';\n\nclass MediaBridge extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      bridge: '',\n      user: ''\n    };\n    this.onRemoteHangup = this.onRemoteHangup.bind(this);\n    this.onMessage = this.onMessage.bind(this);\n    this.sendData = this.sendData.bind(this);\n    this.setupDataHandlers = this.setupDataHandlers.bind(this);\n    this.setDescription = this.setDescription.bind(this);\n    this.sendDescription = this.sendDescription.bind(this);\n    this.hangup = this.hangup.bind(this);\n    this.init = this.init.bind(this);\n    this.setDescription = this.setDescription.bind(this);\n    this.getDisplay = this.getDisplay.bind(this);\n  }\n\n  componentWillMount() {\n    // chrome polyfill for connection between the local device and a remote peer\n    window.RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection;\n    this.props.media(this);\n  }\n\n  componentDidMount() {\n    this.props.getUserMedia.then(stream => this.localVideo.srcObject = this.localStream = stream);\n    this.props.socket.on('message', this.onMessage);\n    this.props.socket.on('hangup', this.onRemoteHangup);\n  }\n\n  componentWillUnmount() {\n    this.props.media(null);\n\n    if (this.localStream !== undefined) {\n      this.localStream.getVideoTracks()[0].stop();\n    }\n\n    this.props.socket.emit('leave');\n  }\n\n  onRemoteHangup() {\n    this.setState({\n      user: 'host',\n      bridge: 'host-hangup'\n    });\n  }\n\n  onMessage(message) {\n    if (message.type === 'offer') {\n      // set remote description and answer\n      this.pc.setRemoteDescription(new RTCSessionDescription(message));\n      this.pc.createAnswer().then(this.setDescription).then(this.sendDescription).catch(this.handleError); // An error occurred, so handle the failure to connect\n    } else if (message.type === 'answer') {\n      // set remote description\n      this.pc.setRemoteDescription(new RTCSessionDescription(message));\n    } else if (message.type === 'candidate') {\n      // add ice candidate\n      this.pc.addIceCandidate(new RTCIceCandidate({\n        sdpMLineIndex: message.mlineindex,\n        candidate: message.candidate\n      }));\n    }\n  }\n\n  sendData(msg) {\n    this.dc.send(JSON.stringify(msg));\n  } // Set up the data channel message handler\n\n\n  setupDataHandlers() {\n    this.dc.onmessage = e => {\n      var msg = JSON.parse(e.data);\n      console.log('received message over data channel:' + msg);\n    };\n\n    this.dc.onclose = () => {\n      this.remoteStream.getVideoTracks()[0].stop();\n      console.log('The Data Channel is Closed');\n    };\n  }\n\n  setDescription(offer) {\n    this.pc.setLocalDescription(offer);\n  } // send the offer to a server to be forwarded to the other peer\n\n\n  sendDescription() {\n    this.props.socket.send(this.pc.localDescription);\n  }\n\n  hangup() {\n    this.setState({\n      user: 'guest',\n      bridge: 'guest-hangup'\n    });\n    this.pc.close();\n    this.props.socket.emit('leave');\n  }\n\n  handleError(e) {\n    console.log(e);\n  } // getDisplay(){\n  //   getDisplayStream().then(stream => {\n  //     stream.oninactive = () => {\n  //       this.pc.removeStream(this.localStream)  \n  //       this.props.getUserMedia.then(() => {\n  //         this.pc.addStream(this.localStream)\n  //       })\n  //     }\n  //     // this.setState({ streamUrl: stream, localStream: stream })\n  //     this.localVideo.srcObject = stream\n  //     this.pc.addStream(stream)   \n  //   })\n  // }\n\n\n  async getDisplay() {\n    try {\n      console.log(1111111);\n      await navigator.mediaDevices.getDisplayMedia().then(stream => {\n        console.log(22222222);\n\n        stream.oninactive = () => {\n          this.pc.removeTrack(this.localStream);\n          this.props.getUserMedia.then(() => {\n            this.pc.addTrack(this.localStream);\n          });\n        }; // this.setState({ streamUrl: stream, localStream: stream })\n\n\n        this.localVideo.srcObject = stream;\n        this.pc.addTrack(stream);\n      });\n    } catch (err) {\n      console.log(err);\n    }\n  }\n\n  init() {\n    // wait for local media to be ready\n    const attachMediaIfReady = () => {\n      this.dc = this.pc.createDataChannel('chat');\n      this.setupDataHandlers();\n      console.log('attachMediaIfReady');\n      this.pc.createOffer().then(this.setDescription).then(this.sendDescription).catch(this.handleError); // An error occurred, so handle the failure to connect\n    }; // set up the peer connection\n    // this is one of Google's public STUN servers\n    // make sure your offer/answer role does not change. If user A does a SLD\n    // with type=offer initially, it must do that during  the whole session\n\n\n    this.pc = new RTCPeerConnection({\n      iceServers: [{\n        url: 'stun:stun.l.google.com:19302'\n      }]\n    }); // when our browser gets a candidate, send it to the peer\n\n    this.pc.onicecandidate = e => {\n      console.log(e, 'onicecandidate');\n\n      if (e.candidate) {\n        this.props.socket.send({\n          type: 'candidate',\n          mlineindex: e.candidate.sdpMLineIndex,\n          candidate: e.candidate.candidate\n        });\n      }\n    }; // when the other side added a media stream, show it on screen\n\n\n    this.pc.onaddstream = e => {\n      console.log('onaddstream', e);\n      this.remoteStream = e.stream;\n      this.remoteVideo.srcObject = this.remoteStream = e.stream;\n      this.setState({\n        bridge: 'established'\n      });\n    };\n\n    this.pc.ondatachannel = e => {\n      // data channel\n      this.dc = e.channel;\n      this.setupDataHandlers();\n      this.sendData({\n        peerMediaStream: {\n          video: this.localStream.getVideoTracks()[0].enabled\n        }\n      }); //sendData('hello');\n    }; // attach local media to the peer connection\n\n\n    this.localStream.getTracks().forEach(track => this.pc.addTrack(track, this.localStream)); // call if we were the last to connect (to increase\n    // chances that everything is set up properly at both ends)\n\n    if (this.state.user === 'host') {\n      this.props.getUserMedia.then(attachMediaIfReady);\n    }\n  }\n\n  render() {\n    return (// <div className=\"container\">\n      //   <div className=\"row\">\n      //     <div className=\"col-md-9\">\n      React.createElement(\"div\", {\n        className: \"media-bridge \".concat(this.state.bridge),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 188\n        },\n        __self: this\n      }, React.createElement(\"video\", {\n        className: \"remote-video\",\n        ref: ref => this.remoteVideo = ref,\n        autoPlay: true,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 189\n        },\n        __self: this\n      }), React.createElement(\"video\", {\n        className: \"local-video\",\n        ref: ref => this.localVideo = ref,\n        autoPlay: true,\n        muted: true,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 190\n        },\n        __self: this\n      })) //     </div>\n      //     <div className=\"col-md-3\">\n      //       asdfasdf\n      //     </div>\n      //   </div>\n      // </div>\n\n    );\n  }\n\n}\n\nMediaBridge.propTypes = {\n  socket: PropTypes.object.isRequired,\n  getUserMedia: PropTypes.object.isRequired,\n  media: PropTypes.func.isRequired\n};\nexport default MediaBridge;","map":{"version":3,"sources":["C:\\Users\\gksdb\\Desktop\\2019-2-OSSP1-Buzz-5\\client\\src\\containers\\MediaContainer.js"],"names":["React","Component","PropTypes","getDisplayStream","MediaBridge","constructor","props","state","bridge","user","onRemoteHangup","bind","onMessage","sendData","setupDataHandlers","setDescription","sendDescription","hangup","init","getDisplay","componentWillMount","window","RTCPeerConnection","webkitRTCPeerConnection","media","componentDidMount","getUserMedia","then","stream","localVideo","srcObject","localStream","socket","on","componentWillUnmount","undefined","getVideoTracks","stop","emit","setState","message","type","pc","setRemoteDescription","RTCSessionDescription","createAnswer","catch","handleError","addIceCandidate","RTCIceCandidate","sdpMLineIndex","mlineindex","candidate","msg","dc","send","JSON","stringify","onmessage","e","parse","data","console","log","onclose","remoteStream","offer","setLocalDescription","localDescription","close","navigator","mediaDevices","getDisplayMedia","oninactive","removeTrack","addTrack","err","attachMediaIfReady","createDataChannel","createOffer","iceServers","url","onicecandidate","onaddstream","remoteVideo","ondatachannel","channel","peerMediaStream","video","enabled","getTracks","forEach","track","render","ref","propTypes","object","isRequired","func"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\r\nimport { PropTypes } from 'prop-types';\r\nimport {getDisplayStream} from './media-access'\r\n\r\nclass MediaBridge extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      bridge: '',\r\n      user: ''\r\n    }\r\n    this.onRemoteHangup = this.onRemoteHangup.bind(this);\r\n    this.onMessage = this.onMessage.bind(this);\r\n    this.sendData = this.sendData.bind(this);\r\n    this.setupDataHandlers = this.setupDataHandlers.bind(this);\r\n    this.setDescription = this.setDescription.bind(this);\r\n    this.sendDescription = this.sendDescription.bind(this);\r\n    this.hangup = this.hangup.bind(this);\r\n    this.init = this.init.bind(this);\r\n    this.setDescription = this.setDescription.bind(this);\r\n    this.getDisplay = this.getDisplay.bind(this);\r\n  }\r\n  componentWillMount() {\r\n    // chrome polyfill for connection between the local device and a remote peer\r\n    window.RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection;\r\n    this.props.media(this);\r\n  }\r\n  componentDidMount() {\r\n    this.props.getUserMedia\r\n      .then(stream => this.localVideo.srcObject = this.localStream = stream);\r\n    this.props.socket.on('message', this.onMessage);\r\n    this.props.socket.on('hangup', this.onRemoteHangup);\r\n  }\r\n  componentWillUnmount() {\r\n    this.props.media(null);\r\n    if (this.localStream !== undefined) {\r\n      this.localStream.getVideoTracks()[0].stop();\r\n    }\r\n    this.props.socket.emit('leave');\r\n  }\r\n  onRemoteHangup() {\r\n    this.setState({user: 'host', bridge: 'host-hangup'});\r\n  }\r\n  onMessage(message) {\r\n      if (message.type === 'offer') {\r\n          // set remote description and answer\r\n          this.pc.setRemoteDescription(new RTCSessionDescription(message));\r\n          this.pc.createAnswer()\r\n            .then(this.setDescription)\r\n            .then(this.sendDescription)\r\n            .catch(this.handleError); // An error occurred, so handle the failure to connect\r\n\r\n      } else if (message.type === 'answer') {\r\n          // set remote description\r\n          this.pc.setRemoteDescription(new RTCSessionDescription(message));\r\n      } else if (message.type === 'candidate') {\r\n          // add ice candidate\r\n          this.pc.addIceCandidate(\r\n              new RTCIceCandidate({\r\n                  sdpMLineIndex: message.mlineindex,\r\n                  candidate: message.candidate\r\n              })\r\n          );\r\n      }\r\n  }\r\n  sendData(msg) {\r\n    this.dc.send(JSON.stringify(msg))\r\n  }\r\n  // Set up the data channel message handler\r\n  setupDataHandlers() {\r\n      this.dc.onmessage = e => {\r\n          var msg = JSON.parse(e.data);\r\n          console.log('received message over data channel:' + msg);\r\n      };\r\n      this.dc.onclose = () => {\r\n        this.remoteStream.getVideoTracks()[0].stop();\r\n        console.log('The Data Channel is Closed');\r\n      };\r\n  }\r\n  setDescription(offer) {\r\n    this.pc.setLocalDescription(offer);\r\n  }\r\n  // send the offer to a server to be forwarded to the other peer\r\n  sendDescription() {\r\n    this.props.socket.send(this.pc.localDescription);\r\n  }\r\n  hangup() {\r\n    this.setState({user: 'guest', bridge: 'guest-hangup'});\r\n    this.pc.close();\r\n    this.props.socket.emit('leave');\r\n  }\r\n  handleError(e) {\r\n    console.log(e);\r\n  }\r\n  \r\n  // getDisplay(){\r\n  //   getDisplayStream().then(stream => {\r\n  //     stream.oninactive = () => {\r\n  //       this.pc.removeStream(this.localStream)  \r\n  //       this.props.getUserMedia.then(() => {\r\n  //         this.pc.addStream(this.localStream)\r\n  //       })\r\n  //     }\r\n  //     // this.setState({ streamUrl: stream, localStream: stream })\r\n  //     this.localVideo.srcObject = stream\r\n  //     this.pc.addStream(stream)   \r\n  //   })\r\n  // }\r\n\r\n  async getDisplay() {\r\n    try {\r\n      console.log(1111111)\r\n      await navigator.mediaDevices.getDisplayMedia().then(stream => {\r\n          console.log(22222222)\r\n          stream.oninactive = () => {\r\n            this.pc.removeTrack(this.localStream)  \r\n            this.props.getUserMedia.then(() => {\r\n              this.pc.addTrack(this.localStream)\r\n            })\r\n        }\r\n        // this.setState({ streamUrl: stream, localStream: stream })\r\n        this.localVideo.srcObject = stream\r\n        this.pc.addTrack(stream)\r\n      })\r\n    } catch(err) {\r\n      console.log(err)\r\n    }\r\n  }\r\n\r\n  init() {\r\n    // wait for local media to be ready\r\n    const attachMediaIfReady = () => {\r\n      this.dc = this.pc.createDataChannel('chat');\r\n      this.setupDataHandlers();\r\n      console.log('attachMediaIfReady')\r\n      this.pc.createOffer()\r\n        .then(this.setDescription)\r\n        .then(this.sendDescription)\r\n        .catch(this.handleError); // An error occurred, so handle the failure to connect\r\n    }\r\n    // set up the peer connection\r\n    // this is one of Google's public STUN servers\r\n    // make sure your offer/answer role does not change. If user A does a SLD\r\n    // with type=offer initially, it must do that during  the whole session\r\n    this.pc = new RTCPeerConnection({iceServers: [{url: 'stun:stun.l.google.com:19302'}]});\r\n    // when our browser gets a candidate, send it to the peer\r\n    this.pc.onicecandidate = e => {\r\n        console.log(e, 'onicecandidate');\r\n        if (e.candidate) {\r\n            this.props.socket.send({\r\n                type: 'candidate',\r\n                mlineindex: e.candidate.sdpMLineIndex,\r\n                candidate: e.candidate.candidate\r\n            });\r\n        }\r\n    };\r\n    // when the other side added a media stream, show it on screen\r\n    this.pc.onaddstream = e => {\r\n        console.log('onaddstream', e) \r\n        this.remoteStream = e.stream;\r\n        this.remoteVideo.srcObject = this.remoteStream = e.stream;\r\n        this.setState({bridge: 'established'});\r\n    };\r\n    this.pc.ondatachannel = e => {\r\n        // data channel\r\n        this.dc = e.channel;\r\n        this.setupDataHandlers();\r\n        this.sendData({\r\n          peerMediaStream: {\r\n            video: this.localStream.getVideoTracks()[0].enabled\r\n          }\r\n        });\r\n        //sendData('hello');\r\n    };\r\n    // attach local media to the peer connection\r\n    this.localStream.getTracks().forEach(track => this.pc.addTrack(track, this.localStream));\r\n    // call if we were the last to connect (to increase\r\n    // chances that everything is set up properly at both ends)\r\n    if (this.state.user === 'host') {\r\n      this.props.getUserMedia.then(attachMediaIfReady);\r\n    }  \r\n  }\r\n  render(){\r\n    return (\r\n      // <div className=\"container\">\r\n      //   <div className=\"row\">\r\n      //     <div className=\"col-md-9\">\r\n            <div className={`media-bridge ${this.state.bridge}`}>\r\n              <video className=\"remote-video\" ref={(ref) => this.remoteVideo = ref} autoPlay></video>\r\n              <video className=\"local-video\" ref={(ref) => this.localVideo = ref} autoPlay muted></video>\r\n            </div>\r\n      //     </div>\r\n      //     <div className=\"col-md-3\">\r\n      //       asdfasdf\r\n      //     </div>\r\n      //   </div>\r\n      // </div>\r\n    );\r\n  }\r\n}\r\nMediaBridge.propTypes = {\r\n  socket: PropTypes.object.isRequired,\r\n  getUserMedia: PropTypes.object.isRequired,\r\n  media: PropTypes.func.isRequired\r\n}\r\nexport default MediaBridge;"]},"metadata":{},"sourceType":"module"}